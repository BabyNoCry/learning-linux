环境变量 

1.基本概念：
环境变量(environment variables)一般是指在操作系统中用来指定操作系统运行环境的一些参数 
如：我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但 是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找。 
环境变量通常具有某些特殊用途，还有在系统当中通常具有全局特性。

2.常见的环境变量
查看环境变量方法 echo $NAME      //name:环境变量名称
	1.PATH ： 指定命令的搜索路径    在系统中查看环境变量echo $PATH
	2.HOME : 指定用户的主工作目录(即用户登陆到Linux系统中时,默认的目录)  作用：	
	3.SHELL : 当前Shell,它的值通常是/bin/bash。 
问题：为什么有些指令可以直接执行，不需要带路径，而我们的二进制程序需要带路径才能执行？ 
PATH环境变量是系统默认查找文件的一些路径，我们的常用的指令程序都存储在某一个路径底下，因此执行时不需要制定路径，系统通过默认的换将变量PATH就可以找到，
而我们的程序通常不在这些路径里面，不指明时系统找不到文件的存储位置，因此需要我们指定路径，才可以运行。
 还有什么方法可以不用带路径，直接就可以运行呢？
1.我们的程序的文件，放在系统的路径底下。（超级用户下）
2.将我们文件所在的路径添加到环境变量中：export PATH=$PATH:【我们要加的路径。】

和环境变量相关的命令：
	1. echo: 显示某个环境变量值 
	2. export: 设置一个新的环境变量 
	3. env: 显示所有环境变量 
	4. unset: 清除环境变量 
	5. set: 显示本地定义的shell变量和环境变量 	
通过代码获取环境变量：
1.  int main(int argc,char* argv[],char* env[])   
main函数的三个默认参数：argc 命令行的命令数，argv 存放命令行的命令，保存env系统的环境变量。（代码省略）
int i = 0;
for(;env[i];i++) 
printf("%d : %s\n",i,env[i]);
2.  通过第三方变量environ   
libc中定义的全局变量environ指向环境变量表,environ没有包含在任何头文件中, 所以在使用时要用extern声明。 
int i = 0;
for(;environ[i];i++) 
printf("%d : %s\n",i,environ[i]);
3.通过系统调用函数获取环境变量
头文件：#include<stdlib.h>
 char *getenv(const char *name);
例：peintf("%s\n",getenv("PATH"));	//输出PATH环境变量的内容
用法例子：在linux命令行输入  myenv=1000（注释：myenv会成为本地变量） 回车 ---->再次输入echo $myenv回车  ----->会显示1000
	但是此时在使用env命令查看所有的命令时，myenv并不存在。想将其导成环境变量，需输入命令：export  myenv 。此时在去执行env时，就可以在所有环境变量中找到myenv=1000，
	此时为了删除该环境变量输入：unset myenv  回车即可。
环境变量的全局特性・：环境变量通常具有全局属性，可以被子进程继承下去。
问题：环境变量是可以被子进程继承下去的！想想为什么？ 
我们知道main函数第三个参数会将系统的环境变量导列表给我们，当我们新设定一个环境变量时，该变量就会被写入环境变量列表中，因此父进程子进程就都可以获得。

 
	

基础IO
我们知道FILE* 是一个指向文件的指针   那么FILE是什么？（结构体）
C语言编写的程序，运行后变成进程，会默认打开三个输入输出流，
stdin(标准输入，对应设备：键盘),stdout（标准输出，对应设备：一般是显示器）,stderr（标准错误，对应设备：一般是显示器）
linux下：一切皆文件，键盘，显示器等都是，我们知道从一个文件中读写数据时，必须要先将文件打开，那为什么我们使用键盘和显示器时从没有主动去去打开这些。
原因：这些都是默认打开的。
ftell 当前写入的位置   fseek 调整写入得位置  fwind 回到文件起始

任何一个进程会默认打开三个文件描述符分别是：0（标准输入）、1（标准输出）、2（标准错误）
文件描述符的本质是：数组的下标。
当打开一个文件时：文件描述符总从最小的未被使用的开始使用。
输出重定向的本质是：'>', 先将1号文件描述符关闭，然后打开一个文件，然后向该文件写数据（以写的方式写入）。
输入重定向：关掉0，然后打开文件。  '<'
追加重定向：关掉1文件描述符，以追加的方式打开文件，然后写数据。'>>'
清空文件的方式之一：>[文件名]   （注释：将什么都没有写入文件，即清空）
三种缓冲方式：行缓冲（遇到换行符刷新）、全缓冲（当缓冲区写满，才进行刷新）、无缓冲。但是：当我们强制刷新时都会刷新。
一般而言，当向显示器打印时是行缓冲，当向文件中写时刷新方案是全缓冲。
注意：linux中不存在缓冲区，即当我们调用系统的接口向文件中写数据时，是直接进行写入的。C语言提供的库函数向文件中写入数据是含有缓冲区的，向显示器中写入时是行缓冲，向文件中写入时是全缓冲。
	

文件系统 
	显示inode号：ls -i

	创建文件：现在inode位图，找一个没使用的，由0置1，然后在对应的inode对应的数据块儿内将文件的属性信息写入，分配块儿号，数据由0置1，写入数据，最后一步，将文件名和inode的映射关系写入当前的目录文件内。
	删除文件:  将两个位图的对应位置由1置0，然后删除目录文件中 该文件和inode的映射关系。
	 
     软硬链接：
	建立硬链接 ：  ln 【原文件名】 【新文件名-h】   
	建立软链接：   ln -s 【原文件名】【新文件名-s】
	     硬链接：没有独立的inode ，可以理解为别名。例：cd test  ==  cd  test-h
	     软链接：目标文件的路径，用法：直接使用软连接运行程序，不用写路径。 例：./test-s

动态库和静态库

	动态库：以.so 结尾  
	静态库：以.a 结尾 
	库的命名：去掉前缀，去掉后缀。 例如：libc.a   库名为c
	静态链接：对库的依赖性低，但文件较大，影响程序的加载时间。
	动态链接:  体积小，加载时间少，但依赖库比较多，编写的程序夸平台性低。

	要使用库：必须提供库对应的.h头文件，和库对应的.a 或.so库文件。
	
	
	如何打库(生成静态库)：ar -rc（replace，creat）目标文件.a  依赖文件    注意：（头文件、库文件）发给别人使用时，除了将生成的静态库打包，还应含有库对应的.h文件。
	gcc  的 选项 大i “-I”后面跟头文件所在的路径，大L   -L库的路径  小L（你要连接哪一个库） -l
	    举例：gcc -o $@ $^ -I(大i) ./lib/include -L ./lib/lib -l mymath（库名）     

	生成动态库:   gcc -shared -o  【库名.so结尾】 【依赖对的.o文件】  注意：这里的.o文件在生成要加-fPIC选项 例：gcc -fPIC -c test.c -o test.o
 	（需要将当前动态库所在的路径加入环境变量 LD_LIBRARY_PATH   (export LD_LIBRARY_PATH= $LD_LIBRARY_PATH:【我们动态库的路径】)）；
		
线程
	线程是在进程的内部，线程是在进程的地址空间内运行的。
	linux 没有真正意义上的线程，而是用进程模拟的。即就是没有（TCB）只有PCB。

进程是承担分配系统资源的基本单位，而线程是调度的基本单位。

进程的重量大（即占用系统资源多），线程轻即占用资源相对较少。linux中，可以将线程看作是“轻量级的进程”。

线程的优点：
	1.创建线程的代价比进程得多
	2.切换成本低：原因：1.上下文信息少 2.页表等都不需要换（共用同一张页表）
	3.占用资源较少（进程的一部分）
	4.充分利用处理器的可并行数量
	5.计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现 
	6./O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作。(效率得提高)

线程的缺点:

	性能损失:
		一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型 线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的 同步和调度开销，而可用的资源不变。
	健壮性降低：（一个线程的异常可能会导致进程退出，而进程的运行具有独立性，一个进程的退出不会影响其他的进程）
		编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了 不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。
	编程难度提高：
		编写与调试一个多线程程序比单线程程序困难得多。

线程的异常：
	1.单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃 
	2.线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该 进程内的所有线程也就随即退出

线程的用途：
	1.合理的使用多线程，能提高CPU密集型程序的执行效率 
	2.合理的使用多线程，能提高IO密集型程序的用户体验（如生活中我们一边写代码一边下载开发工具，就是 多线程运行的一种表现）



linux 进程VS 线程
	1.进程是分配系统资源的基本单位。线程是调度的基本单位。
	2.线程共享进程数据，但也有自己的一部分数据。
		（1）进程ID 	（2）（重要）有自己独立的硬件上下文（用于线程切换） （3）（重要）栈（为什么有栈？线程可能会创建临时变量，也会调用函数）
		（4 ）errno	（5） 信号屏蔽字 	（6） 调度优先级

进程的多个线程共享 同一地址空间,因此Text Segment、Data Segment都是共享的,如果定义一个函数,在各线程中 都可以调用,如果定义一个全局变量,
在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境:
	（1） 文件描述符 （2） 各种信号的处理方式 	（3）当前的工作目录 		（4）用户id 和组id	

线程的控制
	如果线程调用exec系列函数进行程序替换，因为线程间是共享进程的资源的，因此这种情况会将整个进程替换掉，其他的进程也将无法执行。


posix线程库 
	因为linux系统没有真正意义上的线程，而是进程模拟实现的。所以系统本身没有任关于线程的调用的接口，因此用户为了方便使用，就对系统底层相关进行了封装，实现了一系列的接口来对线程进行控制，这就是我们的线程库。
	线程库是用户级别的， 库名 <thread.h>

	创建线程 pthread_creat(pthread_t* thread,void* threadRun, void* arg);   //  参数：1.返回创建的线程的id 地址   2. 线程执行时函数 3. 线程调用函数的参数
	相关命令：ps aux  查看当前系统内部的进程    ps -aL  查看轻量级进程（线程）
	
	渗透内容： 线程的PCB 中的两个成员： int  pid（线程的id）   int tgid; （线程组的id，真正意义上的）
		因此我们通过命令 ps -aL 得到的结果中 pid 对应的是底层中的tgid ， 而 LWP	 对应的是底层中的 pid（线程的id）。


	临界资源:  多线程执行时共享的资源叫做临界资源
	临界区： 访问临界资源的代码叫做临界区
	例：显示器是一个临界资源，而cout 语句用来访问显示器，因此这类语句被称为临界区。
	
	问题： 主线程需要等待新线程退出吗？
		已经退出的线程，其空间没有被释放，仍然在进程的地址空间内。 创建新的线程不会复用刚才退出线程的地址空间。
		答案是需要，与进程相同，如果主进程不等待新线程的退出，就是导致内存泄漏问题。
		而我们主线程关注只是线程退出时的退出码：即就是线程的退出只考虑两种情况，1.代码执行完结果对  2.代码执行完，结果不对。 
		不考虑线程异常的原因是：当线程出现异常会导致整个进程因为异常而退出，主线程也是一样，会退出，因此即使主线程知道新线程因为异常退出，也没有机会返回。
	
	线程等待： pthread_join(thread_t  id,void status);	//参数 1.等待的线程的id 2. 获取线程退出时的退出码（要是不关注新线程退出时的退出码 就设置为NULL）

线程的终止 
	三种终止线程的方式：
			1. 线程内部调用 return  
			2. 线程调用pthread_eixt 。 	注意：线程是在进程内部运行的，那么线程调用exit 就相当于进程调用exit，进程就会退出。除非想通过线程让进程退出，否则不能调用exit函数。 
			3.线程可以被相同进程中的另一个线程取消 调用：pthread_cancel(pthread_t thread);

	分离线程：
	pthread_detach(pthread_t  thread);     //可以是线程自身调用，也可以是别的线程调用来分离另外一个线程。 被分离的线程退出时主线程将不用去释放其资源，而是由系统进行释放（这里与进程等待中的将子进程退出时信号SIGCHILD 的处理方式设置为忽略）
	
线程的互斥：
	pthread_mutex_t  lock;   //定义一个锁。
	pthread_mutex_t_init( pthread_mutex_t* mutex,  NULL);   //初始化一个锁，第二个参数为锁的属性，一般设置为NULL。
	pthread_mutex_t_init(pthread_mutex_t* mutex);	//摧毁一把锁
	
	pthread_mutex_t lock(pthread_mutex_t* mutex);  //上锁，失败则阻塞
	pthread_mutex_t unlock(pthread_mutex_t* mutex); //释放锁
	pthread_mutex_t trylock(pthread_mutex_t* mutex);  //尝试上锁 ，失败则返回

	锁本身是临界资源，它为了保护其他的临界资源必须首先保证自身的安全，即（加锁、解锁是原子操作）
	
	为了实现互斥锁的操作，大多数体系结构都提供了swap 和 exchange指令，作用是将“寄存器和内存单元的数据想交换，一条汇编指令，因此保证了原子性”。
可重入函数与线程安全的联系：
	可重入函数一定是线程安全函数，线程安全函数不一定是可重入函数。

		




	
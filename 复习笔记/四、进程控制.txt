进程地址空间：
为什么要有地址空间：
	1. 保护内存（ 虚拟地址转化为物理地址的过程，可以检查指针的合法性。）
	2. 保证每一进程认为自己独占系统资源，方便进程的设计。
	
注意！！！ 地址空间不是内存。不能用来保存数据。
堆的向上增长，栈向下增长
任何语言指针中保存的地址都不是物理地址而是虚拟地址。
描述进程地址空间的结构体（mm_struct）内部：充满的是一个个整型，用来保存每个地址区域的起始地址和结束地址。存储的数据地址也一样的方式存储。
但是数据必须要存在物理地址，因此必定存在从虚拟地址到物理地址的映射关系（页表---映射关系），实际中由内存管理单元MMU 根据页表来完成虚拟地址到物理地址的转化（页表+MMU---->转化）。
因此创建进程：需要创建，PCB，地址空间，页表，维护好映射关系，加载数据和代码到物理内存。
进程的独立性：进程的代码和数据都私有一份，互不影响。
《深入理解计算机系统》 看第九章（虚拟地址空间）。或者搜索虚拟地址到物理地址的转化方式相关内容，加深理解。
  
进程创建：
	fork后，子进程和父进程的代码是共享的，数据是（写时拷贝）各自私有。
	问题：为什么fork要有两个返回值？
	为什么要写时拷贝（读写数据时拷贝）？
	（节省资源）有可能子进程在运行的过程中并不会用到父进程的数据，因此将数据直接拷贝给子进程可能会是一种浪费，因此数据是以写时拷贝的形式各自私有一份。 
         fork常规使用：
	1.创建一个子进程，是让子进程执行父进程代码中的一部分
	2.彻底的让子进程执行其它的程序。
         fork调用失败的原因：
	1.系统中有太多的进程
	2. 实际用户的进程数超过了限制

	
	

进程的终止
	进程退出的场景：
		1. 代码运行完毕，结果正确
		2. 代码运行完毕，结果不正确
		3. 代码异常终止（例: ctrl + c   信号终止，或因为某个原因：野指针、越界，除0）

	进程常见的退出方法： 可以用（echo $?）查看最近一个程序退出时的退出码
		1. 从main返回     return 0  表示代码的运行的结果对还是不对，通常0表示正常，非0表示不正常
		（重要：main函数的返回值代表当前进程的退出码）
		2. 调用exit  
		return与exit 的不同：在任何地方调用exit都表示当前进程退出，只有在main函数调用return，才代表当前进程退出。
		3. _exit
		与exit的区别：exit会刷新当前进程的缓存区，_exit不会，其他功能都相同，用法也一样。
		exit  ---->执行用户定义的清理函数-----> 冲出缓冲区，关闭流---->系统层面上终止该进程
		_eixt  ----->直接终止进程

进程的等待
	进程等待的必要性：
		子进程退出，父进程如果不管不顾，就可能造成‘僵尸进程’的问题，进而造成内存泄漏。
		 另外，进程一旦变成僵尸状态，那就刀枪不入，“杀人不眨眼”的kill -9 也无能为力，因为谁也没有办法 杀死一个已经死去的进程。 
		最后，父进程派给子进程的任务完成的如何，我们需要知道。如，子进程运行完成，结果对还是不对， 或者是否正常退出。 
		父进程通过进程等待的方式，“回收子进程资源，获取子进程退出信息”。
	
	进程等待得方法：
		wait方法：
		头文件:#include<sys.types.h>
		          #include<sys/wait.h>
		 pid_t  wait(int* status);
		       返回值：    成功返回被等待进程pid，失败返回-1。 
		       参数：    输出型参数，获取子进程退出状态,不关心则可以设置成为NUL
		waitpid(pid_t pid,int* status,int options);  //options(父进程的等待方式（非阻塞式、阻塞方式：子进程不退出，一直在那里等)），0 表示以阻塞方式进行等待
			返回值：    当正常返回的时候waitpid返回收集到的子进程的进程ID；    
				如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；    
				如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在； 
			参数：    
				pid：        Pid=-1,等待任一个子进程。与wait等效。        
					Pid>0.等待其进程ID与pid相等的子进程。    
				status:        WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）       
					 WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）   
				 options:        WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进程的ID。
	查看系统信号列表：kill -l  一共有62个，前31叫做普通信号，后31叫做实时信号。
	kill -9 命令 几乎可以杀死所有的进程，但是有两种进程例外：1. 僵尸进程  2. 进程状态为D（深度睡眠）的进程。
	什么是进程阻塞？
	该进程所等待的条件不满足，操作系统将该进程的状态设置为非R状态，从运行队列中拿走，放置等待队列。
	阻塞式等：说明父进程的状态绝对不是R状态，不在运行队列。

进程程序替换：
	替换原理：用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支),子进程往往要调用一种exec函数 以执行另一个程序。
		当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动 例程开始执行。“调用exec并不创建新进程,所以调用exec前后该进程的id并未改变。”只是将磁盘当中可执行程序的数据和代码进行了替换。
	